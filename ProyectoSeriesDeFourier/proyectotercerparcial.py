# -*- coding: utf-8 -*-
"""ProyectoTercerParcial.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Wkah-4aJcSMtaURrTWUYeRnV4S332iAQ
"""

#---------------------------------------------------------------Librerias a importar------------------------------------------------------------------------
import numpy as np
import matplotlib
import math
from matplotlib.colors import ColorConverter
import matplotlib.pyplot as plt
from sympy import Piecewise, symbols, pi, I, fourier_series, integrate, sympify, cos, sin




#-----------------------------------------Funcion para que el usuario introduzca la funcion a trozos-------------------------------------------------------
def crear_funcion_trozos():
  t = symbols('t')

  numero_funciones = int(input("Ingrese el numero de funciones: "))
  #Arreglo de funciones introducidas
  expresiones = []
  #Arreglo de intervalos
  intervalos = []

  #EL ELEMENTO expresion[0] representaria la primera funcion igualmente intervalos[0]
  #representaria el primer intervalo de la primera funcion

  #Funcion para que el usuario las expresiones del numero de funciones deseadas
  for i in range(numero_funciones):
    #Ingresar las funciones
    expresion_str = input(
        f"\n Ingrese la expresión de la funcion {i + 1} en términos de t: ")

    # Convertir la cadena de texto a una expresión sympy
    expresion = sympify(expresion_str)

   #Ingresa los limites

    limite_izquierdo = (
        input(f"Ingrese el límite izquierdo para el intervalo {i + 1}: "))
    limite_izquierdo= float(eval(limite_izquierdo))
    limite_derecho = (
        input(f"Ingrese el límite derecho para el intervalo {i + 1}: "))
    limite_derecho=float(eval(limite_derecho)) # La función eval() evalúa una expresión proporcionada como cadena.


    #Introduce en un arreglo las funciones y en otro arreglo los intervalos
    expresiones.append(expresion)
    intervalos.append((limite_izquierdo, limite_derecho)) # intervalos[0][0] expresa la funcion 1 y toma su limite izquierdo
    print(f"\n Esta es la expresion {i+1}: {expresion}")



  return  numero_funciones, intervalos,expresiones


#=-----------------------------------------Funcion para calcular los coefiecientes-------------------------------------------------------------

def calcular_coeficientes_fourier(funcion_trozos, n, numero_funciones,intervalos,PGrande):

  t = symbols('t')

  #Declaracion de las variables a utilizar
  a_0=[] # Declaracion de cada a_0 para cada funcion a trozos
  a_nG=[] # a_nG guarda la suma de los correspondientes an de cada funcion a trozos
  b_nG=[] # b_nG guarda la suma de los correspondientes an de cada funcion a trozos

  #Declaracion del arreglo bidimesional de los coeficientes de cada funcion a trozos
  a_n = [[0 for _ in range(n)] for _ in range(numero_funciones)]
  b_n = [[0 for _ in range(n)] for _ in range(numero_funciones)]


  print("\n Verificar que si ingresamos la funcion a trozos correspondiente: ")
  print("\n f(t)= ")
  for i in range(numero_funciones):
    print(f"\n {expresiones[i]} si {intervalos[i][0]} <= t <= {intervalos[i][1]}")


  print("\n Comenzando el calculo de los coeficientes de Fourier")

   #Calculamos los a_0 de cada funcion a trozos
  for i in range(numero_funciones):
    a_0.append((2/ PGrande) * integrate(funcion_trozos[i], (t, (intervalos[i][0]),(intervalos[i][1]))))
    print(f"El coeficiente a0 de {expresiones[i]} es: {a_0[i]} ")


  #Recordar que a_n[0][3] en este caso representaria el tercer coeficiente de la primera funcion a trozos
  #a_n[0][3]  representa el tercer coeficiente de la segunda funcion a trozos
  #entonces a las k funciones a trozos les calcula n coeficientes

  print("\n Comenzando el calculo de los coeficientes an y bn de cada funcion a trozos")
  #Calcula los coeficientes
  for j in range(numero_funciones):
    #Calcula los an y bn de cada funcion a trozos
    for k in range(n):
      a_n[j][k] = (2/PGrande) * integrate(funcion_trozos[j] * cos(t* np.pi * (k+1) * 2/ PGrande),(t, (intervalos[j][0]), (intervalos[j][1]) ))
      b_n[j][k] =(2/PGrande) * integrate(funcion_trozos[j] * sin(t* np.pi * (k+1) * 2/PGrande), (t, (intervalos[j][0]), (intervalos[j][1])))

    #Suma cada an de cada funcion a trozos y introduce la suma en a_nG
    #Ejemplo suma todos los a1 de cada funcion a trozos y el introduce en a_1G, a1T0+a1T1+....+a1Tn=a_nG[0](en este caso el a_nG[0] representa el primer elemento)
    print("\n Sumando cada an y bn de cada funcion a trozos ")
    if j==0:
      for k in range(n):
        a_nG.append(a_n[j][k])
        b_nG.append(b_n[j][k])
    else:
      for k in range(n):
        a_nG[k]=a_nG[k]+a_n[j][k]
        b_nG[k]=b_nG[k]+b_n[j][k]





  print("\n Finalizando el calculo de los coeficientes")

  return a_nG, b_nG,a_0


#=-------------------------------------------------Funcion para realizar la suma---------------------------------------------

def aproximar_funcion_fourier(a_n, b_n, PGrande, n,a0,numero_funciones):
  t = symbols('t')
  suma=0

  print("\n Comenzando el calculo de la funcion de Fourier")
  for i in range(numero_funciones):
    suma=suma+a0[i]/2


  for j in range(n):
    suma= suma+ a_n[j]*cos(t * np.pi * (j+1) * (2 /PGrande)) + b_n[j]*sin(t* np.pi * (j+1) * (2/PGrande))

  print("\n Finalizando el calculo de la funcion de Fourier")
  return suma


#-------------------------------------Main----------------------------------------------------

if __name__ == "__main__":

  #============================Declaracion de variables ==============================================================
  #Detecta a x de manera simbolica y no como variable
  t = symbols('t')

  #Son los arreglos an y bn donde se guardan las sumas de los an y bn
  #correspondientes de las funciones a trozos y la serie de Fourier


  a_n=[]
  b_n=[]
  Funcion_suma = []

  n = 32  # Número de términos para la aproximación(Numero de sumas)
  N = 200 # Número de puntos de muestreo(Para graficar la funcion)

  color_rgb = ColorConverter().to_rgb((155/255, 89/255, 182/255)) #Para modificar el color de la aproximacion con Fourier
  #155/255, 89/255, 182/255, 217, 136, 128 , 82, 190, 128




  #===========================Leer funciones a trozos con su respectivo intervalo======================================================

  numero_funciones, intervalos,expresiones = crear_funcion_trozos()



  PGrande=intervalos[numero_funciones-1][1]-intervalos[0][0]

  print(f"\n El periodo de la funcion a trozos es igual a : {PGrande} ")


 #==============================Calculo de la aproximación con la serie de Fourier==============================================



  #Calcula los coeficientes an y bn(Generales) de la serie de fourier
  a_n, b_n,a0 = calcular_coeficientes_fourier(expresiones, n, numero_funciones,intervalos,PGrande)


  #Calcula la funcion de aproximacion con la serie de fourier
  Funcion_suma.append( aproximar_funcion_fourier(a_n, b_n, PGrande, n,a0,numero_funciones))

  #Imprimir la Serie de Fourier
  print("\nLa serie de Fourier es la siguiente :")
  print(Funcion_suma[0])







  #=====================================Graficando===========================================================

  d= int(input("\n Introduce el numero de periodos a graficar: "))
  print("\n Imprimiendo las graficas, espere profe: ")


  #Dimension de la Grafica
  plt.figure(figsize=(9.2, 7.2))
  #Intervalo a graficar de la Serie de Fourier
  interval = list(np.linspace(intervalos[0][0], intervalos[numero_funciones-1][1]+PGrande*(d-1),N)) # Convierte un array a una lista


  #Funcion que grafica los d periodos de la funcion introducida por el usuario
  for j in range(1,d+1):
    for i in range(numero_funciones):
      intervalf = list(np.linspace(intervalos[i][0]+PGrande*(j-1), intervalos[i][1]+PGrande*(j-1),N)) # Convierte un array a una lista
      intervalf1 = list(np.linspace(intervalos[i][0], intervalos[i][1],N))
      y_values = [expresiones[i].subs(t, val) for val in intervalf1] # Calcula los valores de y
      plt.plot(intervalf, y_values,linewidth=2.4,alpha=1) # Plot la fucion a trozos usando el generador x y los valores de y



  #Grafica d periodos de la Serie de Fourier
  y_values = [Funcion_suma[0].subs(t, val) for val in interval] # Calcula los valores de y
  plt.plot(interval, y_values, label='Aproximación a través de la Serie de Fourier', color=color_rgb,linewidth=4.2,alpha=0.6) # Plot la fucion a trozos usando el generador x y los valores de y
                                                          #Yo :se aprecia mejor el fenomeno de Gibbs linewidht=2,alpha=1 y originales alpha=0.8 ,  con n=125 y N=2000

  if(d==1):
    plt.title(f'Aproximacion con la Serie de Fourier, Grafica con un Periodo')

  else:
    plt.title(f'Aproximacion con la Serie de Fourier, Grafica con {d} Periodos')

  plt.legend(loc='lower right',fontsize='large')
  plt.grid(True)
  plt.show()